---
title: "Normalization"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(dev = 'svg')
options(device = function(file, width, height) {
  svg(tempfile(), width = width, height = height)
})
```

So far, we haven't paid too much attention to normalization. So what it is it? Basically it is a process of taking values of variables of different scales and bringing them to a common scale ([Wikipedia][1]). In this way comparing them is a little more fair. So in the case of gene expression we have read counts all over the place, and we normalize so we can can compare them to each other. So far we have been taking the ```log2``` of the data plus 1 and then normalizing by quantiles using the ```limma``` library. Before normalizing though, it is worth talking about filtering out genes by counts. In a given expression data set, there will be genes expressed at very low levels and they are often removed to increase the power of whatever analysis you are going to do ([Galaxy Project][2]). Here we will remove genes that do not have a mean count above 10.

```{r norm,warning=FALSE,message=FALSE}
load("./lgg.rda")
library(limma)
library(viridis)
lgg$ExpressionData <- lgg$ExpressionData[rowMeans(lgg$ExpressionData)>10,]
#so what does our data initially look like?
boxplot(
  lgg$ExpressionData[,1:20],
  xaxt='n',
  col = magma(10)[2],
  border=magma(10)[1]
  )
#what about taking the log?
boxplot(
  log2(lgg$ExpressionData+1)[,1:20],
  xaxt='n',
  col= magma(10)[5],
  border=magma(10)[7]
  )
#now what about taking the log and normalizing by quantiles?
boxplot(
  normalizeQuantiles(log2(lgg$ExpressionData+1))[,1:20],
  xaxt='n',
  col=magma(10)[7],
  border=magma(10)[2]
  )

```

Here we see that taking the ```log2``` does level the scales quite a bit, but there is still some variation between samples. By using the ```limma``` function ```normalizeQuantiles()``` we achieve a better stabilization between patients. However, this is not the only choice in normalization technique. The ```limma``` library has quite a few different normalization methods to explore. While we can compare these methods by boxplots, it is also useful to plot the standard deviation against the rank of the mean. The ```vsn``` library has a great function, ```meanSDPlot()``` to accomplish just that. In these plots we are essentially looking for the "flattest" plot, indicating a a more successful variance stabilization.


```{r sdplot.func,echo=FALSE,warning=FALSE}
library(ggplot2)
library(matrixStats)
meanSDPlot <- function(x, ranks = TRUE, xlab = ifelse(ranks, "rank(mean)", "mean"),
         ylab = "sd", pch, plot = TRUE, bins = 50, ...) {
  
  stopifnot(is.logical(ranks), length(ranks) == 1, !is.na(ranks))
  
  n = nrow(x)
  if (n == 0L) {
    warning("In 'meanSdPlot': input matrix 'x' has 0 rows. There is nothing to be done.")
    return()
  }
  if (!missing(pch)) {
    warning("In 'meanSdPlot': 'pch' is ignored.")
  }
  
  px   = rowMeans(x, na.rm = TRUE)
  py   = sqrt(matrixStats::rowVars(x, mean = px, na.rm = TRUE))
  rpx  = rank(px, na.last = FALSE, ties.method = "random")
  
  ## run median with centers at dm, 2*dm, 3*dm,... and width 2*dm
  dm        = 0.025
  midpoints = seq(dm, 1-dm, by = dm)
  within    = function(x, x1, x2) { (x >= x1) & (x <= x2) }
  mediwind  = function(mp) median(py[within(rpx/n, mp - 2*dm, mp + 2*dm)], na.rm = TRUE)
  rq.sds    = sapply(midpoints, mediwind)
  
  res = if(ranks) {
    list(rank = midpoints*n, sd = rq.sds, px = rpx, py = py)
  } else {
    list(quantile = quantile(px, probs = midpoints, na.rm = TRUE), sd = rq.sds, px = px, py = py)
  }
  
  fmt = function() function(x) format(round(x, 0), nsmall = 0L, scientific = FALSE)
  
  res$gg = ggplot(data.frame(px = res$px, py = res$py),
                  aes_string(x = "px", y = "py")) + xlab(xlab) + ylab(ylab) +
    geom_hex(bins = bins, ...) +
    scale_fill_gradient(name = "count", trans = "log", labels = fmt()) + 
    geom_line(aes_string(x = "x", y = "y"),
              data = data.frame(x = res[[1]], y = res$sd), color = "red")
  
  if (plot) print(res$gg)
  
  return(invisible(res))
}
```

```{r limma,warning=FALSE,message=FALSE}
library(ggplot2)
library(gridExtra)
#normal data
p1 <- meanSDPlot(
  as.matrix(lgg$ExpressionData),
  plot = FALSE
  )
#log data
p2 <- meanSDPlot(
  as.matrix(
    log2(lgg$ExpressionData+1)
  ),
  plot = FALSE
)
#log data and normalize by quantiles
p3 <- meanSDPlot(
  as.matrix(
    normalizeQuantiles(log2(lgg$ExpressionData+1))
  ),
  plot = FALSE
)
#log data and normalize by median values
p4 <- meanSDPlot(
  as.matrix(
    normalizeMedianValues(log2(lgg$ExpressionData+1))
  ),
  plot = FALSE
)
#let's plot!
grid.arrange(p1$gg+ggtitle("Raw Data"),
             p2$gg+ggtitle("Log2"),
             p3$gg+ggtitle("Log2+Quantiles"),
             p4$gg+ggtitle("Log2+Median Values"),
             ncol=2)
```

Here again we can see that Log2 transformation does a lot of the work in stabilizing variance. However, methods like ```normalizeQuantiles()``` and ```normalizeMedianValues()``` do go further to provide a better variance stabilization.

## References

1. https://en.wikipedia.org/wiki/Normalization_(statistics)

2. https://training.galaxyproject.org/training-material/topics/transcriptomics/tutorials/rna-seq-counts-to-genes/tutorial.html#filtering-to-remove-lowly-expressed-genes

[1]: https://en.wikipedia.org/wiki/Normalization_(statistics)

[2]: https://training.galaxyproject.org/training-material/topics/transcriptomics/tutorials/rna-seq-counts-to-genes/tutorial.html#filtering-to-remove-lowly-expressed-genes